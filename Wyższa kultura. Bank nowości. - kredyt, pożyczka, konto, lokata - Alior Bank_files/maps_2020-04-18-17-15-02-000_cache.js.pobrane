var Maps = {
    /**
     * @property {Object} _mainBox - main range map container
     */
    _mainBox: null,

    /**
     * @property {String} _mapCanvasId - container ID, where map is placed in
     */
    _mapCanvasId: 'map-container',

    /**
     * @property {Object} _mapOptions - Google Maps API options (common)
     */
    _commonMapOptions: {},

    /**
     * @property {Object} _facilitiesMapOptions - Google Maps API options
     */
    _facilitiesMapOptions: {
        maxZoom: 19,
        minZoom: 5
    },

    /**
     * @property {Object} _position - center position of Poland
     */
    _position: {
        lat: 52.2249148894828,
        lng: 19.342889906249983
    },

    /**
     * @property {Object} _mapInst - Google Maps instance
     */
    _mapInst: null,

    /**
     * @property {LatLng} _centerMapLatlng - latitute and longitude of Poland
     */
    _centerMapLatlng: null,

    /**
     * @property {Array} _facilities - facilities data given from JSON
     */
    _facilities: {
        branch: null,
        atm: null,
        pm: null
    },

    /**
     * @property {Array} _storesMarkerInstances - each marker has unique name (dynamically generated by name and unique ID)
     */
    _facilitiesMarkerInstances: [],

    /**
     * @property {MarkerClusterer} _markerClustererInstance
     */
    _markerClustererInstance: null,


    /**
     * @property {Array} _facilityMarkerIcon
     */

    _facilityMarkerIcon: {
        branch: [
            (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/yellow_marker.png',
            (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/burgundy_marker.png',
            (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/green_marker.png',
            (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/blue_marker.png',
            (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/brown_marker.png',
            (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/black_marker.png'
        ],
        atm: (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/burgundy_marker.png',
        pm: (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/burgundy_marker.png'
    },

    /**
     * @property {String} _facilityClusterMarkerIcon
     */
    _facilityClusterMarkerIcon: (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/burgundy_circle.png',

    /**
     * @property {String} _closeBoxURL
     */
    _closeBoxURL: (~window.location.pathname.indexOf('/magnoliaAuthor') ? '/magnoliaAuthor' : '') + '/.resources/templating-kit/themes/alior/img/localizator/infobox_close.png',

    /**
     * @property {String} _clusterMarkerCssClass - CSS class for each marker coming from MarkerClusterer
     */
    _clusterMarkerCssClass: 'cluster-marker',

    /**
     * @property {Object} _mapType - map types
     * (we use it in at least 2 places, so it must be configurable from this place)
     */
    _mapType: {
        BRANCH: 'branch',
        ATM: 'atm',
        PM: 'pm'
    },

    /**
     * @property {String} _branchTypesId - container ID of branch type filters
     */
    _branchTypesId: 'branch-types',

    /**
     * @property {Object} _branchTypesBox - branch type filters container
     */
    _branchTypesBox: null,

    /**
     * @property {String} _locationTypeId - container ID of location type selection
     */
    _locationTypeId: 'location-type',

    /**
     * @property {Object} _locationTypeBox - location type selection container
     */
    _locationTypeBox: null,

    /**
     * @property {Object} _urlParameters
     */
    _urlParameters: {
        id: null,
        type: null
    },

    /**
     * @property {String} _headerId - ID name for _headerContainer
     */
    _headerId: 'header',

    /**
     * @property {Object} _headerContainer - jQuery object
     */
    _headerContainer: null,

    /**
     * @property {String} _scrollDownClass - Class name for _scrollDownContainer
     */
    _scrollDownClass: 'scroll-map-down',

    /**
     * @property {Object} _scrollDownContainer - jQuery object
     */
    _scrollDownContainer: null,

    /**
     * Init map module
     */
    init: function() {
        this._mainBox = $('.map-container');

        if (!this._mainBox.length) {
            return;
        }

        // read parameters from URL
        this.parseQueryString();

        // set basic properties
        this._setProperties();

        this.search.init();

        this.infoWindow.init();

        this._initMap();

        this._initBranchTypes();

        this._initLocationTypes();
        this._setLocationType();

        var selectedMapType = this._getSelectedMapType();
        this._switchMap(selectedMapType);

        this.toggleBranchTypes(selectedMapType);
        this.search.toggleSearchLocationFiltersBox();
        this.search._clearSearchResultsBox();
        this.search._toggleResultsFilters(selectedMapType);

        this.search.findLocationById(this._urlParameters.id);

        this.getHeaderContainer();
        this.createScrollDown();

        this.initEvents();
    },


    /**
     * Gets _headerContainer
     */
    getHeaderContainer: function() {
        this._headerContainer = $('#' + this._headerId);
    },

    /**
     * Creates Scroll Down
     */
    createScrollDown: function() {
        this._scrollDownContainer = $('<div />');
        this._scrollDownContainer.addClass(this._scrollDownClass);

        this._scrollDownContainer.appendTo(this._mainBox);
    },

    /**
     * Parses query string
     */
    parseQueryString: function() {
        var query = (window.location.search || '?').substr(1),
            obj   = {};
        query.replace(/([^&=]+)=?([^&]*)(?:&+|$)/g, function(match, key, value) {
            (obj[key] = obj[key] || []).push(value);
        });

        $.extend(this._urlParameters, obj);
    },

    /**
     * Sets location type according to type parameter in url query string
     */
    _setLocationType: function() {
        if (this._urlParameters.type && this._urlParameters.type.length) {
            this._locationTypeBox.find('select option').filter('[value="' + this._urlParameters.type[0] + '"]').prop('selected', true);
            this._locationTypeBox.find('select').trigger('change');
        }
    },

    /**
     * Inits events
     */
    initEvents: function() {
        this.initLocationTypeChange();
        this.initBranchTypesClick();
        this.initScrollDownClick();
    },

    /**
     * Inits click event on _scrollDownContainer
     */
    initScrollDownClick: function() {
        this._scrollDownContainer.on('click', this._scrollToMapBottom.bind(this));
    },

    /**
     * Inits location types
     */
    _initLocationTypes: function() {
        this._getLocationTypeBox();
        this._buildMobileLocationTypeNav();
        this._initMobileLocationTypeNavClick();
    },

    /**
     * Inits click event on .mobile-location-type span
     */
    _initMobileLocationTypeNavClick: function() {
        $('.mobile-location-type').on('click', 'span', this._mobileLocationTypeNavClick.bind(this));
    },

    /**
     * _locationTypeBox change event callback
     */
    _locationTypeNavChange: function(e) {
        var target = $(e.currentTarget),
            value = target.val(),
            mobileNav = $('.mobile-location-type'),
            options = mobileNav.find('span'),
            option;

        for (var i = 0, l = options.length; i < l; i++) {
            option = $(options[i]);

            if (option.data('value') === value) {
                this._toggleMobileLocationTypeNavClass(option);
            }
        }
    },

    /**
     * .mobile-location-type span click event callback
     */
    _mobileLocationTypeNavClick: function(e) {
        var target = $(e.currentTarget),
            value = target.data('value'),
            selectOptions = this._locationTypeBox.find('.newList li'),
            option;

        for (var i = 0, l = selectOptions.length; i < l; i++) {
            option = $(selectOptions[i]);

            if (option.data('key') === value) {
                option.find('a').trigger('click');
            }
        }
    },

    /**
     * Adds 'active' class for selected location type
     */
    _toggleMobileLocationTypeNavClass: function(target) {
        var container = target.closest('.mobile-location-type');

        container.find('li').removeClass('active');
        target.parent().addClass('active');
    },

    /**
     * Generates mobile menu from location type select
     * which is visible on mobile only
     */
    _buildMobileLocationTypeNav: function() {
        var list = $('<ul>'),
            options = this._locationTypeBox.find('option'),
            option, newOption;

        for (var i = 0, l = options.length; i < l; i++) {
            option = options[i];
            newOption = $('<li/>');

            newOption.html('<span data-value="' + option.value + '">' + $(option).text() + '</span>');

            if (option.selected) {
                newOption.addClass('active');
            }

            list.append(newOption);
        }
        list.addClass('mobile-location-type');

        this._locationTypeBox.append(list);
    },

    /**
     * Gets _locationTypeBox container
     */
    _getLocationTypeBox: function() {
        this._locationTypeBox = $('#' + this._locationTypeId);
    },

    /**
     * Inits change event on select in _locationTypeBox
     */
    initLocationTypeChange: function() {
        var self = this;

        this._locationTypeBox.find('select').on('change', function(e) {
            self._locationTypeNavChange(e);
            self._changeFacility();
        });
    },

    /**
     * select in _locationTypeBox change event callback
     * Changes facility
     */
    _changeFacility: function() {
        var selectedMapType = this._getSelectedMapType();

        this.toggleBranchTypes(selectedMapType);

        this.search._clearSearchInput();
        this.search._clearLocationResults();
        this.search.toggleSearchLocationFiltersBox();
        this.search._hideLocationResultsGeneratePdf();
        this.search._clearSearchResultsBox();
        this.search._toggleResultsFilters(selectedMapType);

        this._switchMap(selectedMapType);
    },

    /**
     * Toggles visibility of branch types
     */
    toggleBranchTypes: function(locationType) {
        if (locationType === this._mapType['BRANCH']) {
            this._branchTypesBox.parent().removeClass('hide');
        } else {
            this._branchTypesBox.parent().addClass('hide');
        }
    },

    /**
     * Inits click event on input[type="checkbox"] in _branchTypesBox
     */
    initBranchTypesClick: function() {
        this._branchTypesBox.on('click', 'input', this.filterBranchTypes.bind(this));
    },

    /**
     * Gets selected branch types from _branchTypesBox checkboxes
     */
    _getSelectedBranchTypes: function() {
        return this._branchTypesBox.find('input:checked');
    },

    /**
     * Gets Ids from selected branch types
     */
    _getSelectedBranchTypesIds: function() {
        var checked = this._getSelectedBranchTypes(),
            ids = [];

        if (checked && checked.length) {
            checked.each(function() {
                ids.push($(this).val());
            });

        }

        return ids;

    },

    /**
     * Filters markers on the map according to selected branch types
     */
    filterBranchTypes: function() {
        var checked = this._getSelectedBranchTypes(),
            cLength = checked.length;

        this.infoWindow.closeCurrent();

        if (cLength) {
            this.setAllMarkersVisibility(false);
            this.showChoosenBranchTypes(checked);
            this._hideAllFacilitiesMarkers();
        } else {
            this.setAllMarkersVisibility(true);
        }

        this.rerenderMarkerClustererInstance();
    },

    /**
     * Gets checked branch types values
     */
    _getCheckedBranchTypesValues: function(checked) {
        var checkedValues = [];

        checked.each(function() {
            checkedValues.push(parseInt($(this).val()));
        });

        return checkedValues;
    },

    /**
     * Shows choosen branch types markers on the map
     * @param checked
     */
    showChoosenBranchTypes: function(checked) {
        var checkedTypes = this._getCheckedBranchTypesValues(checked),
            i = 0,
            l = this._facilitiesMarkerInstances.length,
            markerInstance;

        for (; i < l; i++) {
            markerInstance = this._facilitiesMarkerInstances[i];
            markerInstance.setVisible(checkedTypes.indexOf(parseInt(markerInstance.type)) !== -1);
        }
    },

    /**
     * Sets all facility markers visibility
     * @property {Boolean} visible - visibility flag
     */
    setAllMarkersVisibility: function(visible) {
        var i = 0,
            l = this._facilitiesMarkerInstances.length,
            markerInstance;

        for (; i < l; i++) {
            markerInstance = this._facilitiesMarkerInstances[i];
            markerInstance.setVisible(visible);
        }
    },

    /**
     * Inits branch types
     */
    _initBranchTypes: function() {
        this._getBranchTypesBox();
        this._appendBranchTypesIcons();
    },

    /**
     * Appends branch types icons to filter checkboxes
     */
    _appendBranchTypesIcons: function() {
        var self = this,
            types = this._branchTypesBox.find('.checkbox'),
            input, label, txt,
            isEnglish = $('body').hasClass('english');

        types.each(function(index, item) {
            input = $(item).find('input');
            label = $(item).find('label');
            txt = label.text();

            label.html('<img src="' + self._facilityMarkerIcon['branch'][input.val()] + '" /><span>' + txt + '</span>');

        });
    },

    /**
     * Gets _branchTypesBox container
     */
    _getBranchTypesBox: function() {
        this._branchTypesBox = $('#' + this._branchTypesId);
    },

    /**
     * Gets selected map (location) type value
     */
    _getSelectedMapType: function() {
        return this._locationTypeBox.find('select').val();
    },

    /**
     * Scrolls to top of the map container
     */
    _scrollToMapTop: function() {
        var top = parseInt(this._mainBox.offset().top),
            offset = 86;

        $("html, body").animate({ scrollTop: top - (offset * 2)}, 400);
    },

    /**
     * Scrolls to bottom of the map container
     */
    _scrollToMapBottom: function() {
        var bottom = parseInt(this._mainBox.offset().top + this._mainBox.outerHeight(true) + this._headerContainer.outerHeight(true));

        $("html, body").animate({ scrollTop: bottom}, 600);
    },

    /**
     * Gets map zoom value according to size of the browser window
     * (mobile or desktop with small height)
     */
    _getZoom: function() {
        var zoom,
            width = window.outerWidth,
            height = window.outerHeight;

        if (width < 641 || width >= 641 && height <= 800) {
            zoom = 5;
        } else {
            zoom = 6
        }

        return zoom;
    },

    /**
     * Sets basic properties
     *
     * @private
     */
    _setProperties: function() {
        this._commonMapOptions = {
            //center:             this._centerMapLatlng,
            // scrollwheel:        false,
            mapTypeId:          google.maps.MapTypeId.ROADMAP,
            disableDefaultUI:   true,
            streetViewControl:  true,
            zoom:               this._getZoom(),
            zoomControl:        true,
            styles: [{
                "featureType": "poi",
                "elementType": "labels",
                "stylers": [{
                    "visibility": "off"
                }]
            }]
        };
    },

    /**
     * Sets center map coordinates
     *
     * @private
     */
    _setCenterMapLatlng: function() {
        var self = this;

        this._mapInst = new google.maps.Map(document.getElementById(self._mapCanvasId), self._commonMapOptions);
        this._mapInst.setCenter(this._position);

        var docUrl = window.location.href,
            isGetByIdUrl = docUrl.indexOf("branch") > -1;

        if (navigator.geolocation && !isGetByIdUrl) {
            navigator.geolocation.getCurrentPosition(function(position) {
                var newZoom = 15;

                self._position = new google.maps.LatLng(position.coords.latitude, position.coords.longitude),

                self._mapInst.setCenter(self._position);
                self._mapInst.setZoom(newZoom);
                self.geolocalization.setMarker(self._position);
            }, function(err) {
                // The Geolocation service failed
                console.log('The Geolocation service failed');
            });
        } else {
            // Browser doesn't support Geolocation
            console.log('Browser doesn\'t support Geolocation');
        }
    },

    /**
     * Init map instance
     *
     * @private
     */
    _initMap: function() {
        this._setCenterMapLatlng();
        //this._mapInst = new google.maps.Map(document.getElementById(this._mapCanvasId), this._commonMapOptions);
    },

    /**
     * Switch map by type
     *
     * @param {String} type - 'ranges' or 'stores'
     * @private
     */
    _switchMap: function(type) {
        this._clearMap();

        switch (type) {

            case this._mapType['ATM']:
            case this._mapType['PM']:
            case this._mapType['BRANCH']:
                this.route.hideAll();
                this.route.init();
                this.geolocalization.hideCurrentMarker();
                this.infoWindow.closeCurrent();
                this._mapInst.setValues(this._facilitiesMapOptions);

                // init facilities markers with showing them on the map
                this._initFacilities(type, this._showAllFacilitiesMarkers.bind(this));
                this.filterBranchTypes();
                // this.route.init();
                break;

            default:
                throw new Error('maps.js :: _switchMap :: invalid param type. Value given: ' + type);
        }
    },

    /**
     * Inits facilities. Fills map with facilities. If we don't have facilities cached, first we need get it via AJAX.
     *
     * @private
     */
    _initFacilities: function(type, successCb) {
        if (!this._facilities[type]) {
            this._getFacilitiesToCache(type, (function() {
                // this._fillMapWithFacilities();
                this._fillMap(type);
                AliorBase.callback(successCb, this);
            }).bind(this));
        } else {
            this._fillMap(type);
            AliorBase.callback(successCb, this);
        }
    },

    /**
     * Fill map
     * Check if _facilities[type] is an object first and throw error if not
     */
    _fillMap: function(type) {
        var prop;

        if (!AliorBase.isObject(this._facilities[type])) {
            throw new Error('maps.js :: _fillMap() :: The this._facilities is not an object. this._facilities[type]: ', this._facilities[type]);
        }

        for (prop in this._facilities[type]) {
            if (this._facilities[type].hasOwnProperty(prop)) {
                this._fillMapWithFacilities(this._facilities[type][prop], prop);
            }
        }
    },

    /**
     * Fills map with facilities (get from cache this._facilities)
     *
     * @private
     */
    _fillMapWithFacilities: function(facilities, city) {
        var facilitiesLength = facilities.length;

        for (var i=0; i<facilitiesLength; i++) {
            var facility = facilities[i];

            this.setFacilityMarkerOnTheMap(facility, city);
        }
    },

    /**
     * Hides all facilities markers (with clusters)
     *
     * @private
     */
    _hideAllFacilitiesMarkers: function() {
        if (this._markerClustererInstance && this._markerClustererInstance instanceof MarkerClusterer) {
            this._markerClustererInstance.clearMarkers();
        }
    },

    /**
     * Rerenders markers on the map
     */
    rerenderMarkerClustererInstance: function() {
        this._markerClustererInstance.addMarkers(this.getFilteredMarkers());
    },

    /**
     * Gets filtered (visible) markers
     */
    getFilteredMarkers: function() {
        var output = [],
            i = 0,
            l = this._facilitiesMarkerInstances.length,
            markerInstance;

        for (; i < l; i++) {
            markerInstance = this._facilitiesMarkerInstances[i];

            if (markerInstance.visible) {
                output.push(markerInstance);
            }
        }

        return output;
    },

    /**
     * Shows all facilities markers, then clusters them
     *
     * @private
     */
    _showAllFacilitiesMarkers: function() {
        var markersLength = this._facilitiesMarkerInstances.length;

        for (var i=0; i<markersLength; i++) {
            var markerInst = this._facilitiesMarkerInstances[i];

            markerInst.setVisible(true);
        }

        // we need to extend Marker Clusterer function and add to each marker custom CSS class
        if (AliorBase.isFunction(ClusterIcon)) {
            var clusterIconOnAddFunction = ClusterIcon.prototype.onAdd;

            ClusterIcon.prototype.onAdd = function() {
                clusterIconOnAddFunction.apply(this, arguments);

                $(this.div_).addClass(Maps._clusterMarkerCssClass);
            }
        }

        this.getMarkerClustererOptions();
        this._markerClustererInstance = new MarkerClusterer(this._mapInst, this._facilitiesMarkerInstances, this.markerClustererOptions);
    },

    /**
     * Gets options for MarkerClusterer
     */
    getMarkerClustererOptions: function() {
        var self = this;

        this.markerClustererOptions = {
            gridSize: 50,
            maxZoom: 18,

            // we can't add these sizes via CSS, because MarkerClusterer plugin calculates incorrect
            styles: [{
                height: 28,
                width: 28,
                textColor: '#fff',
                textSize: 14,
                url: self._facilityClusterMarkerIcon
            },{
                height: 28,
                width: 28,
                textColor: '#fff',
                textSize: 14,
                url: self._facilityClusterMarkerIcon
            },{
                height: 28,
                width: 28,
                textColor: '#fff',
                textSize: 14,
                url: self._facilityClusterMarkerIcon
            },{
                height: 28,
                width: 28,
                textColor: '#fff',
                textSize: 14,
                url: self._facilityClusterMarkerIcon
            },{
                height: 28,
                width: 28,
                textColor: '#fff',
                textSize: 14,
                url: self._facilityClusterMarkerIcon
            }]
        };
    },

    /**
     * Gets facilities from JSON file then assigns it to the object (cache)
     *
     * @param {Function} successCb - success callback
     * @private
     */
    _getFacilitiesToCache: function(type, successCb) {
        this._facilities[type] = JSON.parse(document.getElementById(type).innerHTML);
        AliorBase.callback(successCb, this, [this._facilities]);
    },

    /**
     * Resets map to the default state - without range layers, markers etc.
     * @private
     */
    _clearMap: function()
    {
        // this._hideAllRanges();
        this._hideAllFacilitiesMarkers();
        this.clearAllFacilitiesMarkers();
    },

    /**
     * Sets store marker on the map (based on store data from JSON)
     *
     * @param {Object} storeData
     * @returns {google.maps.Marker}
     */
    setFacilityMarkerOnTheMap: function(facilityData, city) {
        var selectedMapType = Maps._getSelectedMapType(),
            latLng = new google.maps.LatLng(facilityData.lt, facilityData.lg),

            markerInstance = new google.maps.Marker({
                position: latLng,
                map: this._mapInst,
                title: facilityData.name,
                icon: selectedMapType === this._mapType['BRANCH'] ? this._facilityMarkerIcon[selectedMapType][facilityData.t] : this._facilityMarkerIcon[selectedMapType]

            });

        markerInstance.set('id', facilityData.o);
        markerInstance.set('city', city);
        markerInstance.set('type', facilityData.t);
        markerInstance.setVisible(false);

        Maps._facilitiesMarkerInstances.push(markerInstance);

        // bind window events to marker
        this.infoWindow.bindToMarker(markerInstance, facilityData, city);

        return markerInstance;
    },

    /**
     * Clears all facilities markers from the map, then removes its related instance from  _facilitiesMarkerInstances property
     */
    clearAllFacilitiesMarkers: function() {
        var i = 0,
            facilitiesMarkerInstancesLength = Maps._facilitiesMarkerInstances.length,
            markerInstance;

        for (; i < facilitiesMarkerInstancesLength; i++) {
            markerInstance = Maps._facilitiesMarkerInstances[i];
            markerInstance.setMap(null);
        }

        Maps._facilitiesMarkerInstances = [];
    },

    /**
     * Gets marker by ID
     */
    getMarkerById: function(id) {

        idType = parseInt(id);


        if(isNaN(idType)) {

            var result = $.grep(this._facilitiesMarkerInstances, function(marker) {
                return marker.id === id;
            });

        } else {

            var result = $.grep(this._facilitiesMarkerInstances, function(marker) {
                return parseInt(marker.id) === parseInt(id);
            });

        }


        return result[0];
    },

    /**
     * Info Window module
     */
    infoWindow: {

        /**
         * @property {jQuery} _tpl - basic template
         */
        _tpl: null,

        /**
         * @property {Object} _windows - info window instances (grouped by marker ID = store ID)
         */
        _windows: {},

        /**
         * @property {InfoBox} _currentOpened - current opened infowindow (using for closing current one)
         */
        _currentOpened: null,

        /**
         * @property {Object} _windowOptions - additional default options
         */
        _windowOptions: {},

        /**
         * @property {jQuery} _routeBox - a box, where route time info will be displayed
         */
        _routeBox: null,

        /**
         * Sets basic properties of the module
         * @private
         */
        _setProperties: function()
        {
            this._windowOptions = {
                maxWidth: 190,
                disableAutoPan: false,
                zIndex: null,
                pixelOffset: new google.maps.Size(5, -50),
                closeBoxMargin: "25px 25px 0 0",
                closeBoxURL: Maps._closeBoxURL
            };
        },

        /**
         * Returns rendered template string
         *
         * @param {Object} data - facility data
         * @param {String} markerId - marker ID
         * @returns {String}
         * @private
         */
        _renderTemplate: function(data, markerId, city) {
            var tpl = this._tpl.clone(),
                selectedMapType = Maps._getSelectedMapType(),
                // city = data.pc + ' ' + data.c,
                facilityNameBox = tpl.find('.facility-name'),
                addressDataBox = tpl.find('.address-data'),
                hoursBoxWrapper = tpl.find('.available-hours-box'),
                hoursBox = tpl.find('.available-hours'),
                routeBox = tpl.find('.route-container'),
                moreBox = tpl.find('.more-details');

            facilityNameBox.text(data.n);

            addressDataBox.find('.address-street').text(data.s);
            if (selectedMapType !== Maps._mapType['BRANCH']) {
                addressDataBox.find('.address-city').text(city);
            } else {
                addressDataBox.find('.address-city').text(data.pc + ' ' + city);
            }

            if (data.h) {
                hoursBoxWrapper.removeClass('hide');
                this._renderOpenHours(hoursBox, data.h);
            }

            routeBox.find('.set-route').attr('data-route-id', markerId);
            moreBox.find('.see-more').attr('data-city', city).attr('data-id', markerId);

            return tpl[0].outerHTML;
        },

        /**
         * Returns markup for opening hours element
         * @param {openDay} Integer
         * @param {openHours} String
         */

        _getOpenElement: function(openDay, openHours) {
            var isEnglish = $('body').hasClass('english');

            if (isEnglish) {
                return '<li><span class="open-day">' + AliorBase.dictionary.daysEn[openDay] + '</span><span class="open-hours">' + openHours + '</li>';
            } else {
                return '<li><span class="open-day">' + AliorBase.dictionary.days[openDay] + '</span><span class="open-hours">' + openHours + '</li>';
            }

        },

        /**
         * Renders opening hours
         *
         * @param {container} jQuery object container
         * @param {openings} array
         * @private
         */
        _renderOpenHours: function(container, openings) {
            var l = openings.length,
                i, j, opening;

            if (parseInt(openings[l - 1].d) === 7) {
                opening = openings[l - 1];

                for (i = 0; i < 5; i++) {
                    container.append(this._getOpenElement(i, opening.h));
                }

                for (j = 0; j < l - 1; j++) {
                    opening = openings[j];
                    container.append(this._getOpenElement(parseInt(opening.d), opening.h));
                }
            } else {
                for (i = 0; i < l; i++) {
                    opening = openings[i];
                    container.append(this._getOpenElement(parseInt(opening.d), opening.h));
                }

                // no saturday & sunday in JSON
                for (j = 0; j < 2; j++) {
                    container.append(this._getOpenElement(j + 5, '-'));
                }
            }
        },

        /**
         * Opens window related to marker given as a param
         *
         * @param {google.maps.Marker} marker
         * @private
         */
        _open: function(marker)
        {
            // we need to close currently opened window when we open another one
            this.closeCurrent();

            this._currentOpened = this._windows[marker.id];
            this._currentOpened.open(Maps._mapInst, marker);
        },

        /**
         * On domready window callback
         *
         * @param {InfoBox} window
         * @param {google.maps.Marker} marker
         * @private
         */
        _onShow: function(window, marker) {
            var windowBox = $(window.div_);

            this._routeBox = windowBox.find('.route-container');

            // we need to unbind previous events
            windowBox.off('click.close');
            windowBox.off('click.route');
            windowBox.off('click.details');

            windowBox.on('click.close', '.close-infobox', this._onCloseClick.bind(this));
            windowBox.on('click.route', '.set-route', this._onRouteClick.bind(this));
            windowBox.on('click.details', '.see-more', this._onSeeDetailsClick.bind(this));
        },

        /**
         * Click on close icon of the info window
         *
         * @param e
         * @private
         */
        _onCloseClick: function(e) {
            e.preventDefault();

            this.closeCurrent();
        },

        /**
         * Click event on 'show on map'
         *
         * @param e
         * @private
         */
        _onShowOnMapClick: function(e) {
            e.preventDefault();

            var el = $(e.currentTarget),
                routeId = el.data('routeId'),
                marker = Maps.getMarkerById(routeId),
                selectedMapType = Maps._getSelectedMapType(),
                facilities = Maps._facilities[selectedMapType],
                location;

            for (location in facilities) {
                if (facilities.hasOwnProperty(location)) {
                    this._getLocation(routeId, selectedMapType, location);
                }
            }
        },

        _getLocation: function(id, selectedMapType, location) {
            var l =  Maps._facilities[selectedMapType][location].length,
                locId;

            for(var i = 0; i < l; i++) {
                loc = Maps._facilities[selectedMapType][location][i];

                id = isNaN(id) ? id : parseInt(id, 10);
                locId = isNaN(loc.o) ? loc.o : parseInt(loc.o, 10);

                if (id === locId) {
                    result = loc;
                    var position = {
                        lat: loc.lt,
                        lng: loc.lg
                    };

                    Maps._mapInst.setCenter(position);
                    Maps._mapInst.setZoom(19);
                    break;
                }
            }
        },

        /**
         * Click event on 'set route'
         *
         * @param e
         * @private
         */
        _onRouteClick: function(e) {
            e.preventDefault();

            var el = $(e.currentTarget),
                routeId = el.data('routeId'),
                marker = Maps.getMarkerById(routeId);

            Maps.route.getDataByDestinationMarker(marker, /* success callback */ function(markerId, from, to) {
                Maps.route.calculate(from, to, markerId, (function(response) {

                    Maps.geolocalization.setMarker(from);
                    Maps.infoWindow.closeCurrent();
                    Maps.route._directionsDisplay.setDirections(response);

                }).bind(Maps.route));
            });
        },

        /**
         * Click event on 'see-more'
         *
         * @param e
         */
        _onSeeDetailsClick: function(e) {
            var el = $(e.currentTarget),
                selectedMapType = Maps._getSelectedMapType(),
                city = el.data('city'),

                // id = parseInt(el.data('id'), 10),
                id = isNaN(el.data('id')) ? el.data('id') : parseInt(el.data('id'), 10);

                isInSearchResults = false,
                resultsSize = Maps.search._locationResults.length;

            if (resultsSize) {
                var i = 0,
                    locationResult;

                for (; i < resultsSize; i++) {
                    locationResult = Maps.search._locationResults[i];

                    // console.log(locationResult, 'wynik');

                    if (locationResult.o === id) {
                        isInSearchResults = true;
                        break;
                    }
                }

            }

            if (!isInSearchResults) {
                var loc = this._getLocationFromCityById(
                        Maps._facilities[selectedMapType][city], id
                    );

                Maps.search._clearSearchResultsBox();
                Maps.search._searchLocationFiltersBox.addClass('hide');
                Maps.search._closestLocationCity = city;

                Maps.search.showResult(loc);
            }

            this.scrollToSearchResult(id);
        },

        /**
         * Gets location from city locations by ID
         * @param {Array} locations
         * @param {Number} id
         */
        // _getLocationFromCityById: function(locations, id) {
        _getLocationFromCityById: function(locations, id) {
            var i = -1,
                l = locations.length,
                result = null,
                location,
                locationId;

            while(++i < l) {
                location = locations[i];

                // locationId = parseInt(location.o, 10);
                locationId = isNaN(location.o) ? location.o : parseInt(location.o, 10);

                // console.log(locationId, id, 'ID');

                if (locationId === id) {
                    result = location;
                    break;
                }
            }

            return result;
        },

        /**
         * Scrolls to search result position
         * @param {Number} id
         */
        scrollToSearchResult: function(id) {
            var searchResult = Maps.search._searchResultsBox.find('[data-route-id="' + id + '"]'),
                top = parseInt(searchResult.position().top),
                offset = 86;

            searchResult.addClass('open').find('.result-details').fadeIn('fast');
            $("html, body").animate({ scrollTop: top - offset}, 600);
        },

        /**
         * Close currently opened window
         * @private
         */
        closeCurrent: function() {
            if (this._currentOpened instanceof InfoBox) {
                this._currentOpened.close();
                this._currentOpened = null;
            }
        },

        /**
         * Infobox module init
         */
        init: function() {
            this._setProperties();
            this.setBasicTemplate();
        },

        /**
         * Sets basic template property
         */
        setBasicTemplate: function() {
            var tplDomObject = Maps._mainBox.find('.facility-info-box');

            if (!tplDomObject.length) {
                throw new Error('maps.js :: setBasicTemplate() :: The InfoBox template is not present in DOM.');
            }

            this._tpl = tplDomObject.clone();
            this._tpl.removeClass('hide');
        },

        /**
         * Binds event to marker (for opening box with facility details)
         *
         * @param {google.maps.Marker} marker
         * @param {Object} facilityData
         */
        bindToMarker: function(marker, facilityData, city) {
            var content = this._renderTemplate(facilityData, marker.id, city),
                options = $.extend({
                    content: content
                }, this._windowOptions),
                win;

            this._windows[facilityData.o] = new InfoBox(options);

            win = this._windows[facilityData.o];

            google.maps.event.addListener(win, 'domready', this._onShow.bind(this, win, marker));
            google.maps.event.addListener(marker, 'click', this._open.bind(this, marker));
        }
    },

    /**
     * Search module
     */
    search: {

        /**
         * @property {google.maps.places.Autocomplete} _autocompleteInst
         */
        _autocompleteInst: null,

        /**
         * @property {google.maps.Geocoder} geocoder
         */
        geocoder: null,

        /**
         * @property {String} _searchLocationInputId - ID of search input
         */
        _searchLocationInputId: 'search-location',

        /**
         * @porperty {HTMLInputElement} - search input element
         */
        _searchInputEl: null,

        /**
         * @property {Boolean} _duringSearchProcess - determine if search is in progress - prevents duplicating requests
         */
        _duringSearchProcess: false,

        /**
         * @property {String} _closestLocationCity - closest location city from found coordinates
         */
        _closestLocationCity: null,

        /**
         * @property {Array} _visibleMarkers - array holding visible markers on the map
         */
        _visibleMarkers: [],

        /**
         * @property {Boolean} _abroadLocation - flag determining wether
         * found coordinates are in Poland or not
         */
        _abroadLocation: false,

        /**
         * @property {String} _searchLocationFiltersId - ID of the search result filters container
         */
        _searchLocationFiltersId: 'search-location-filters',

        /**
         * @property {Object} _searchLocationFiltersBox - jQuery container of the search result filters
         */
        _searchLocationFiltersBox: null,

        /**
         * @property {Object} _locationFilters - search result filters (checkboxes)
         */
        _locationFilters: null,

        /**
         * @property {String} _searchLocationResultsId - ID of the search result list container
         */
        _searchLocationResultsId: 'search-location-results',

        /**
         * @property {Object} _searchResultsBox - jQuery container of the search result list
         */
        _searchResultsBox: null,

        /**
         * @property {Array} _locationResults - list of locations in searched city
         */
        _locationResults: [],
        _locationResultsFiltered: [],

        /**
         * @property {Array} _selectedFilters - list of selected search results filters
         */
        _selectedFilters: [],

        /**
         * @property {jQuery} _tpl - basic template for search result position
         */
        _tpl: null,

        /**
         * @property {String} _searchLocationResultsGeneratePdfId - ID of the PDF generation link container (export search result list to PDF)
         */
        _searchLocationResultsGeneratePdfId: 'search-location-generate-pdf',

        /**
         * @property {Object} _searchLocationResultsGeneratePdfBox - jQuery container of the PDF generation
         */
        _searchLocationResultsGeneratePdfBox: null,

        /**
         * Init search module
         */
        init: function()
        {
            this.geocoder = new google.maps.Geocoder();

            this._searchInputEl = document.getElementById(this._searchLocationInputId);
            this._autocompleteInst = new google.maps.places.Autocomplete(this._searchInputEl, {
                types: ['address'],
                componentRestrictions: {
                    country: 'pl'
                }
            });
            this._autocompleteInst.setFields(['address_components', 'geometry', 'icon', 'name']);
            this._getSearchLocationFiltersBox();
            this._getLocationFilters();
            this._uncheckAllCheckboxes();
            this._getSearchResultsBox();
            this._getResultsTemplate();
            this._getSearchResultsGeneratePdfBox();
            this._initEvents();

            // this._toggleLastFoundValue();
        },

        /**
         * Search events init
         *
         * @private
         */
        _initEvents: function() {
            var self = this;

            // place_changed event, i.e. when we select some value from autocomplete list, search process is running
            google.maps.event.addListener(this._autocompleteInst, 'place_changed', this._runSearchProcess.bind(this));

            this._searchResultsBox.on('click', '.result-main-info', function() {
                $(this).closest('.location-result').toggleClass('open').find('.result-details').fadeToggle('fast');
            });

            this._searchResultsBox.on('click', '.result-route .value', function(e) {
                Maps.infoWindow._onRouteClick(e);
                Maps._scrollToMapTop();
            });

            this._searchResultsBox.on('click', '.result-show-map .value', function(e) {
                Maps.infoWindow._onShowOnMapClick(e);
                Maps._scrollToMapTop();
            });

            this._searchLocationFiltersBox.on('click', '.toggle-location-filters', function() {
                $(this).toggleClass('open');
                self._searchLocationFiltersBox.find('.location-filters').fadeToggle('fast');
            });

            this._locationFilters.on('click', this._filterSearchResults.bind(this));

            $('.icon-lupa').on('click', this._runSearchProcess.bind(this));

            this._searchLocationResultsGeneratePdfBox.find('.value').on('click', this.generatePdfClick.bind(this));
        },

        /**
         * Generate PDF file click
         */
        generatePdfClick: function() {
            var self = this,
                url = self._searchLocationResultsGeneratePdfBox.data('path') + '/.locator/generatePdf',
                xhr = new XMLHttpRequest(),
                options = {
                    location: placeName = $(self._searchInputEl).val(),
                    types: Maps._getSelectedBranchTypesIds(),
                    branchIds: self.getLocationResultsIdsFiltered()
                },

                serializedOptions = $.param(options, true);


            xhr.onreadystatechange = function(){
                if (this.readyState == 4 && this.status == 200){
                    // check for a filename
                    var filename = "",
                        disposition = xhr.getResponseHeader('Content-Disposition'),
                        filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/,
                        matches = filenameRegex.exec(disposition),
                        type = xhr.getResponseHeader('Content-Type'),
                        blob = this.response;

                    if (disposition && disposition.indexOf('attachment') !== -1) {
                        if (matches != null && matches[1]) filename = matches[1].replace(/['"]/g, '');
                    }

                    if (typeof window.navigator.msSaveBlob !== 'undefined') {
                        // IE workaround for "HTML7007: One or more blob URLs were revoked by closing the blob for which they were created. These URLs will no longer resolve as the data backing the URL has been freed."
                        window.navigator.msSaveBlob(blob, filename);
                    } else {
                        var URL = window.URL || window.webkitURL,
                            downloadUrl = URL.createObjectURL(blob);

                        if (filename && filename.length) {
                            // use HTML5 a[download] attribute to specify filename
                            var a = document.createElement("a");
                            // mobile devices
                            if (typeof a.download === 'undefined'){ application/pdf
                                var reader = new FileReader();
                                reader.onload = function(e) {
                                    var bdata = btoa(reader.result),
                                    // datauri = 'data:application/pdf;base64,' + bdata;
                                    datauri = 'data:application/pdf;base64,' + bdata;
                                    window.location.href = datauri;
                                }
                                reader.readAsBinaryString(blob);
                            } else {
                                a.href = downloadUrl;
                                a.download = filename;
                                a.target = '_blank';
                                document.body.appendChild(a);
                                a.click();
                            }

                            setTimeout(function () { URL.revokeObjectURL(downloadUrl); }, 100); // cleanup
                        } else {
                            window.location = downloadUrl;
                        }

                    }
                }
            }

            xhr.open('POST', url, true);
            xhr.responseType = 'blob';
            xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
            xhr.send(serializedOptions);
        },

        /**
         * Gets IDs from search results list
         */
        getLocationResultsIds: function() {
            var output = [],
                i = 0,
                l = this._locationResults.length,
                location;

            for (; i < l; i++) {
                location = this._locationResults[i];
                output.push(location.o);

            }

            return output;

        },


        /**
         * Gets IDs from search results list - after Filter
         */
        getLocationResultsIdsFiltered: function() {

            var output = [],
                i = 0,
                l = this._locationResults.length,
                location;

                 var el = document.getElementById('search-location-results'),
                     f = document.getElementById('search-location-results').childNodes,
                     k = el.childNodes.length,
                     locationResultsFiltered = [];


             for (; i < k; i++) {
                var fac = f[i],
                    location = fac.getAttribute("data-route-id");
                    output.push(location);
             }

            // for (; i < l; i++) {
            //     location = this._locationResultsF[i];
            //     output.push(location.o);

            // }

            return output;

        },



        /**
         * Clears _selectedFilters array
         */
        _clearSelectedFilters: function() {
            this._selectedFilters = [];
        },

        /**
         * Unchecks checkboxes (search results filters)
         */
        _uncheckAllCheckboxes: function() {
            var filtersLength = this._locationFilters.length,
                i = 0,
                filter;

            for (; i < filtersLength; i++) {
                filter = this._locationFilters[i];
                filter.checked = false;
            }
        },

        /**
         * Gets selected filters for search results
         */
        _getSelectedFilters: function() {
            var filtersLength = this._locationFilters.length,
                i = 0,
                filter;

            for (; i < filtersLength; i++) {
                filter = this._locationFilters[i];

                if (filter.checked) {
                    this._selectedFilters.push(filter.value);
                }
            }
        },

        /**
         * Click event on search result filters checkboxes
         * Triggers search results filtering
         */
        _filterSearchResults: function() {
            this._clearSelectedFilters();
            this._getSelectedFilters();
            this._renderResultsTemplate();
            this.updateResultsQuantityFiltered();
        },

        /**
         * Gets search results filters (checkboxes)
         */
        _getLocationFilters: function() {
            this._locationFilters = $('.location-filters').find('input[type="checkbox"]');
        },

        /**
         * Toggles visibility of the search results filters
         * @param {String} locationType
         */
        _toggleResultsFilters: function(locationType) {
            if (locationType === Maps._mapType['BRANCH']) {
                this._showToggleLocationFilters();
                this._showLocationFilters();
            } else {
                this._hideToggleLocationFilters();
                this._hideLocationFilters();
            }
        },

        /**
         * Hides search results filters containter
         */
        _hideLocationFilters: function() {
            var filters = this._searchLocationFiltersBox.find('.location-filters'),
                display = filters.attr('style'),
                pattern = new RegExp('block');

            filters.addClass('hide');

            if (display && pattern.test(display)) {
                filters.hide();
            }
        },

        /**
         * Shows search results filters container
         */
        _showLocationFilters: function() {
            var filters = this._searchLocationFiltersBox.find('.location-filters'),
                display = filters.attr('style'),
                pattern = new RegExp('none');

            filters.removeClass('hide');

            if (display && pattern.test(display)) {
                filters.show();
            }
        },

        /**
         * Hides search results filters toggle span
         */
        _hideToggleLocationFilters: function() {
            this._searchLocationFiltersBox.find('.toggle-location-filters').addClass('hide');
        },

        /**
         * Shows search results filters toggle span
         */
        _showToggleLocationFilters: function() {
            this._searchLocationFiltersBox.find('.toggle-location-filters').removeClass('hide');
        },

        /**
         * Gets _searchLocationFiltersBox - container for search results filters
         */
        _getSearchLocationFiltersBox: function() {
            this._searchLocationFiltersBox = $('#' + this._searchLocationFiltersId);
        },

        /**
         * Gets _searchResultsBox - container for search results list
         */
        _getSearchResultsBox: function() {
            this._searchResultsBox = $('#' + this._searchLocationResultsId);
        },

        /**
         * Gets template for search result position
         */
        _getResultsTemplate: function() {
            this._tpl = this._searchResultsBox.find('.location-result');
        },

        /**
         * Gets container for PDF generation link
         */
        _getSearchResultsGeneratePdfBox: function() {
            this._searchLocationResultsGeneratePdfBox = $('#' + this._searchLocationResultsGeneratePdfId);
        },

        /**
         * Clears visible markers array
         */
        clearVisibleMarkers: function() {
            this._visibleMarkers = [];
        },

        /**
         * Takes current value from input, then make search request
         *
         * @private
         */
        _runSearchProcess: function()
        {
            var self = this,
                placeName = $(this._searchInputEl).val();

            // due to asynchronous requests we need to prevent duplicate requests by fast clicking...
            this._duringSearchProcess = true;

            if (localStorage.getItem(placeName)) {
                var results = JSON.parse(localStorage.getItem(placeName));

                // in terms of Google query limit (I guess per second), we need to check if results are returned.
                // Otherwise we could get an error as results would be null in that case
                if (results) {
                    this.checkForAbroadLocation(results);
                    this.showFoundArea(results);
                    this.getVisibleMarkers(results);

                    if (!this._visibleMarkers.length && !this._abroadLocation) {
                        this.correctBounds(results);
                    }

                    this.showLocationResults(results);
                }

                // We disable search input for a moment to hide keyboard
                // on mobile devices after search process
                $(this._searchInputEl).prop('disabled', true);
                setTimeout(function() {
                    $(self._searchInputEl).removeProp('disabled').removeAttr('disabled');
                }, 100);

                // ... and we reset the flag to false to let make another request
                this._duringSearchProcess = false;
            } else {
                this.geocoder.geocode({
                    address: placeName,
                    componentRestrictions: {
                        country: 'pl'
                    }
                }, (function(results, status) {
                    // in terms of Google query limit (I guess per second), we need to check if results are returned.
                    // Otherwise we could get an error as results would be null in that case
                    if (results && status === google.maps.GeocoderStatus.OK) {
                        if (!JSON.parse(localStorage.getItem(placeName))) {
                            localStorage.setItem(placeName, JSON.stringify(results));
                        }
                        this.checkForAbroadLocation(results);
                        this.showFoundArea(results);
                        this.getVisibleMarkers(results);

                        if (!this._visibleMarkers.length && !this._abroadLocation) {
                            this.correctBounds(results);
                        }

                        this.showLocationResults(results);
                    }

                    // We disable search input for a moment to hide keyboard
                    // on mobile devices after search process
                    $(this._searchInputEl).prop('disabled', true);
                    setTimeout(function() {
                        $(self._searchInputEl).removeProp('disabled').removeAttr('disabled');
                    }, 100);

                    // ... and we reset the flag to false to let make another request
                    this._duringSearchProcess = false;
                }).bind(this));
            }
        },

        /**
         * Shows found area on the map (zoom-in, center etc.), but WITHOUT marker
         *
         * @param {Object} results
         * @private
         */
        showFoundArea: function(results) {
            if (!results) {
                throw new Error('maps.js :: Invalid param results. Value given: ' + results);
            }

            var bounds = new google.maps.LatLngBounds();

            bounds.union(results[0].geometry.viewport);

            Maps._mapInst.fitBounds(bounds);
            Maps._mapInst.setCenter(results[0].geometry.location);

            if (!this._abroadLocation) {
                Maps._mapInst.setZoom(20);
            }
        },

        /**
         * Sorts search results by closest location ID
         * Puts closest location as first index in _locationResults array
         * @param {Number} closestLocationId
         */
        sortLocationResults: function(closestLocationId) {
            var resultsLength = this._locationResults.length,
                i = 0,
                result, item;

            for (; i < resultsLength; i++) {
                result = this._locationResults[i];

console.log(closestLocationId);

                if (result.o === closestLocationId) {
                    item = this._locationResults.splice(i, 1);
                    this._locationResults.unshift(item[0]);
                }
            }
        },

        /**
         * Checks if single search result should be displayed on the results list
         * according to selected filters
         * @param {Object} result - single search result
         */
        showFilteredResult: function(result) {
            var filtersLength = this._selectedFilters.length,
                show = true,
                pattern = new RegExp('r'),
                i = 0,
                filter, filterStr;

            if (result.p && result.p.length) {
                for (i = 0; i < filtersLength; i++) {
                    filter = this._selectedFilters[i];

                    if (pattern.test(filter)) {
                        filterStr = operatingRange[filter].value.toString();
                        show = show && result.r.indexOf(filterStr) !== -1;
                    } else {
                        filterStr = facilityProperties[filter].value.toString();
                        show = show && result.p.indexOf(filterStr) !== -1;
                    }
                }

                if (show) {
                    this._locationResultsFiltered.push(result);
                    this.showResult(result);
                }
            }
        },

        /**
         * Shows result according to search result filters
         * @param {Object} result - single search result
         * @param {String} [locationCity] - name of city
         */
        showResult: function(result, locationCity) {
            var tpl = this._tpl.clone(),
                resultName = tpl.find('.result-name'),
                resultAddress = tpl.find('.result-address'),
                resultAdditionalBox = tpl.find('.result-details-additional-info'),
                resultAdditionalDataInfo = tpl.find('.result-additional-data-info'),
                address,
                hoursBoxWrapper = tpl.find('.available-hours-box'),
                hoursBox = tpl.find('.available-hours'),
                resultAdditionalInfoBox = tpl.find('.result-additional-info'),
                operatingRange = tpl.find('.result-operating-range'),
                operatingRangeText = this._buildOperatingRange(result),
                resultProperties = tpl.find('.result-properties'),
                resultUnavailable = tpl.find('.result-unavailable'),
                resultUnavailableContainer = tpl.find('.result-unavailable-container'),
                resultPhone = tpl.find('.result-phone'),
                resultMail = tpl.find('.result-mail'),
                routeBox = tpl.find('.result-route'),
                centerMapBox = tpl.find('.result-show-map');

            if (!this._closestLocationCity && locationCity) {
                this._closestLocationCity = locationCity;
            }

            if (result.pc) {
                address = result.s + ', ' + result.pc + ' ' + this._closestLocationCity;
            } else {
                address = result.s + ', ' + this._closestLocationCity;
            }

            if (result.ai) {
                resultAdditionalBox.removeClass('hide');
                resultAdditionalDataInfo.html(result.ai);
            }

            resultName.text(result.n);
            resultAddress.text(address);

            if (result.h) {
                hoursBoxWrapper.removeClass('hide');
                Maps.infoWindow._renderOpenHours(hoursBox, result.h);
            }

            if (result.p || result.r || result.u) {
                resultAdditionalInfoBox.removeClass('hide');
            }

            if (result.p) {
                result.cs = result.cl || '';
                result.ch = result.ch || '';
                this._renderProperties(resultProperties, result.p, result.cl, result.ch);
            }

            if (result.i) {
                resultPhone.removeClass('hide');
                resultPhone.find('.value').text(result.i).after('<a href="tel:' + result.i + '">' + result.i + '</a>');
            }

            if (result.e) {
                resultMail.removeClass('hide');
                resultMail.find('.value').html('<a href="mailto:' + result.e + '">' + result.e + '</a>');
            }

            if (result.u) {
                var cl = '',
                    ch = '';

                resultUnavailableContainer.removeClass('hide');
                this._renderProperties(resultUnavailable, result.u, cl, ch);
            }

            routeBox.find('.value').attr('data-route-id', result.o);
            centerMapBox.find('.value').attr('data-route-id', result.o);
            tpl.attr('data-route-id', result.o);

            operatingRange.text(operatingRangeText);

            tpl.removeClass('hide');
            this._searchResultsBox.append(tpl);
        },

        /**
         * Renders properties for single search result
         * @param {Object} container - container of the properties
         * @param {Array} properties - list of single search result properties
         */
        _renderProperties: function(container, properties, cl, ch) {
            var l = properties.length,
                i, j, property;

            for (i = 0; i < l; i++) {
                property = properties[i];

                // nie wyswietlamy otwarte w sobote i niedziele
                if (parseInt(property) !== 7 && parseInt(property) !== 8) {
                    container.append(this._getPropertyElement(property, cl, ch));
                }
            }
        },

        /**
         * Gets single property for rendering properties of the single result
         * @param {String} property - single search result property
         */
        _getPropertyElement: function(property, cl, ch) {
            if(facilityProperties['p[' + property + ']']) {
                if(property == 2) {
                    return '<li class="small-12 medium-4 left branch-property-' + property + '" data-equalizer-watch>' + facilityProperties['p[' + property + ']'].name + '<br>' + ch + '</li>';
                }
                else if (property == 9) {
                    return '<li class="small-12 medium-4 left branch-property-' + property + '" data-equalizer-watch>' + facilityProperties['p[' + property + ']'].name + '<br>' + cl + '</li>';
                }
                else {
                    return '<li class="small-12 medium-4 left branch-property-' + property + '" data-equalizer-watch>' + facilityProperties['p[' + property + ']'].name + '</li>';
                }
            }
        },

        /**
         * Gets operating range for search result template rendering
         * @param {Object} result - single search result
         */
        _buildOperatingRange: function(result) {

            var range = '',
                rangeArray = [],
                i, l, item;

            if (result.r && AliorBase.isArray(result.r) && result.r.length) {
                for (i = 0, l = result.r.length; i < l; i++) {
                    item = result.r[i];

                    rangeArray.push(operatingRange['r[' + item + ']'].name);
                    // rangeArray.push(AliorBase.dictionary.operatingRange[item]);
                }

                range = rangeArray.join(', ');
            }

            return range;
        },

        /**
         * Clear search results list container
         */
        _clearSearchResultsBox: function() {
            this._searchResultsBox.empty();
        },

        /**
         * Clears _locationResults array - list of locations in searched city
         */
        _clearLocationResults: function() {
            this._locationResults = [];
            this._locationResultsFiltered = [];
        },

        /**
         * Clears only _locationResultsFiltered array - list of locations in searched city
         */
        _clearLocationResultsFiltered: function() {
            this._locationResultsFiltered = [];
        },

        /**
         * Clears search input value
         */
        _clearSearchInput: function() {
            $(this._searchInputEl).val('');
        },

        /**
         * Renders search results list
         */

        _renderResultsTemplate: function() {
            var resultsLength = this._locationResults.length,
                filtersLength = this._selectedFilters.length,
                i = 0,
                result;

                // var element = document.getElementById('search-location-results');
                // var numberOfChildren = element.getElementsByClassName('location-result').length;
                //  console.log(numberOfChildren);

            this._clearSearchResultsBox();
            this._clearLocationResultsFiltered();

            if (!this._abroadLocation) {
                for (; i < resultsLength; i++) {
                    result = this._locationResults[i];

                    if (filtersLength) {
                        this.showFilteredResult(result);
                    } else {
                        this.showResult(result);
                    }
                }
            }
        },

        /**
         * Shows PDF generation container
         */
        _showLocationResultsGeneratePdf: function() {
            this._searchLocationResultsGeneratePdfBox.find('.column').removeClass('hide');
        },

        /**
         * Hides PDF generation container
         */
        _hideLocationResultsGeneratePdf: function() {
            this._searchLocationResultsGeneratePdfBox.find('.column').addClass('hide');
        },

        /**
         * Callback for search process
         * @param {Array} results - list of found locations
         */
        showLocationResults: function(results) {
            var selectedMapType = Maps._getSelectedMapType(),
                closestLocation = this.getClosestLocation(results[0].geometry.location),
                checked = Maps._getSelectedBranchTypes(),
                checkedTypes = Maps._getCheckedBranchTypesValues(checked);

            if (!closestLocation) return;
            this._closestLocationCity = closestLocation.city;
            this._locationResults = Maps._facilities[selectedMapType][this._closestLocationCity];
            // console.log('this',this._locationResults);
            this._filterSearchResultsBySelectedBranchTypes();

            this.sortLocationResults(closestLocation.id);
            this._clearSelectedFilters();
            this._uncheckAllCheckboxes();
            this.updateResultsQuantity();

            this.updateResultsQuantityFiltered();

            this.toggleSearchLocationFiltersBox();
            this._renderResultsTemplate();
            this._showLocationResultsGeneratePdf();

            $("#search-location-results").find("[data-route-id='" + closestLocation.id + "']").addClass('open');
        },

        /**
         * Filters search results list according to checked branch types filters
         * Works only with 'branch' map (location) type
         */
        _filterSearchResultsBySelectedBranchTypes: function() {
            var selectedMapType = Maps._getSelectedMapType(),
                checked = Maps._getSelectedBranchTypes(),
                checkedTypes = Maps._getCheckedBranchTypesValues(checked),
                i = 0,
                l = this._locationResults.length,
                output = [],
                location;

            if (selectedMapType === Maps._mapType['BRANCH'] && checkedTypes && checkedTypes.length) {
                for (; i < l; i++) {
                    location = this._locationResults[i];

                    if (checkedTypes.indexOf(parseInt(location.t)) !== -1) {
                        output.push(location);
                    }
                }

                this._locationResults = output;
            }

        },

        /**
         * Toggles visibility of the search results filters container
         */
        toggleSearchLocationFiltersBox: function() {
            var resultsLength = this._locationResults.length;

            if (resultsLength && !this._abroadLocation) {
                this._searchLocationFiltersBox.removeClass('hide');
            } else {
                this._searchLocationFiltersBox.addClass('hide');
            }
        },

        /**
         * Updates quantity of the search results
         */
        updateResultsQuantity: function() {
            var quantity = this._abroadLocation ? 0 : this._locationResults.length;

            this._searchLocationFiltersBox.find('#results-quantity').text(quantity);
        },

        /**
         * Updates quantity of the search results after Filters
         */

        updateResultsQuantityFiltered: function() {
            var quantity = this._abroadLocation ? 0 : this._locationResults.length;

            if (this._selectedFilters.length) {
                quantity = this._abroadLocation ? 0 : this._locationResultsFiltered.length;
            }

            this._searchLocationFiltersBox.find('#results-quantity').text(quantity);

            this._getLocationFilters();
        },


        /**
         * Gets closest location
         * @param {Object} position - found position
         */
        getClosestLocation: function(position) {
            var markersLength = Maps._facilitiesMarkerInstances.length,
                result =  null,
                i = 0,
                marker, tempDistance, distance;


            for (; i < markersLength; i++) {
                marker = Maps._facilitiesMarkerInstances[i];

                if (marker.visible) {
                    tempDistance = google.maps.geometry.spherical.computeDistanceBetween(position, marker.position);

                    if (tempDistance.toString() !== 'NaN') {
                        if (!result) {
                            result = marker;
                            distance = tempDistance;
                        } else {
                            if (distance > tempDistance) {
                                result = marker;
                                distance = tempDistance;
                            }
                        }
                    }
                }
            };

            return result;
        },

        /**
         * Corrects map bounds
         * @param results - search results
         */
        correctBounds: function(results) {
            var closestLocation = this.getClosestLocation(results[0].geometry.location),
                bounds = new google.maps.LatLngBounds();

            if (closestLocation) {
                bounds.extend(closestLocation.position);
                bounds.extend(results[0].geometry.location);

                Maps._mapInst.fitBounds(bounds);
                Maps._mapInst.setCenter(bounds.getCenter());
            }
        },

        /**
         * Gets visible markers
         * @param results - search results
         */
        getVisibleMarkers: function(results) {
            var bounds = Maps._mapInst.getBounds(),
                markersLength = Maps._facilitiesMarkerInstances.length,
                i = 0,
                marker, pos;

            this.clearVisibleMarkers();

            for (; i < markersLength; i++) {
                marker = Maps._facilitiesMarkerInstances[i]
                pos = marker.getPosition();

                if (bounds.contains(pos)) {
                    this._visibleMarkers.push(marker);
                }
            };
        },

        /**
         * Checks if search location is in Poland or not
         * @param results - search results
         */
        checkForAbroadLocation: function(results) {
            var resultsLength = results.length,
                i, addressComponents, j, addressComponentsLength,
                component;

            for (i = 0; i < resultsLength; i++) {
                addressComponents = results[i].address_components,
                addressComponentsLength = addressComponents.length;

                for (j = 0; j < addressComponentsLength; j++) {
                    component = addressComponents[j];

                    if (component.types.indexOf('country') !== -1) {
                        this._abroadLocation = component.short_name !== 'PL';
                        break;
                    }
                }
            }
        },

        /**
         * Finds location by ID in city locations
         * @param {Number} id - location ID
         * @param {String} selectedMapType - selected map (location) type
         * @param {String} location - location city name
         */
        _findLocationByIdInFacility: function(id, selectedMapType, location) {
            var i = 0,
                l = Maps._facilities[selectedMapType][location].length,
                result = null,
                loc;

            for (; i < l; i++) {
                loc = Maps._facilities[selectedMapType][location][i];


                if (parseInt(loc.o, 10) === parseInt(id, 10)) {

                    result = loc;
                    break;
                }
            }

            return result;
        },

        /**
         * Finds location by ID in selected map type
         * @param {Number} id - ID of the location
         */
        findLocationById: function(id) {

            var selectedMapType = Maps._getSelectedMapType(),
                facilities = Maps._facilities[selectedMapType],
                location,
                result;

            if (id && id.length) {
                for (location in facilities) {
                    if (facilities.hasOwnProperty(location)) {

                        result = this._findLocationByIdInFacility(id[0], selectedMapType, location);
                        if (result !== null) {

                            this.goToFoundLocation(result);
                            Maps.search.showResult(result, location);
                            break;
                        }
                    }
                }
            }
        },

        /**
         * Goes to location on the map, zooms to it and opens infoWindow
         * @param {Object} loc - location
         */
        goToFoundLocation: function(loc) {
            var position = {
                    lat: loc.lt,
                    lng: loc.lg
                },
                newZoom = 19;

            Maps._mapInst.setCenter(position);
            Maps.infoWindow._open(Maps.getMarkerById(loc.o));
            Maps._mapInst.setZoom(newZoom);
        }
    },

    /**
     * Routes module
     */
    route: {
        /**
         * @property {google.maps.DirectionsService} _directionsService
         */
        _directionsService: null,

        /**
         * @property {google.maps.DirectionsRenderer} _directionsDisplay
         */
        _directionsDisplay: null,

        /**
         * @property {String} travelMode
         *
         * Possible options:
         * DRIVING      - indicates standard driving directions using the road network.
         * BICYCLING    - requests bicycling directions via bicycle paths & preferred streets.
         * TRANSIT      - requests directions via public transit routes.
         * WALKING      - requests walking directions via pedestrian paths & sidewalks.
         */
        travelMode: 'DRIVING',

        /**
         * Init route module
         */
        init: function() {
            this._directionsService = new google.maps.DirectionsService();
            this._directionsDisplay = new google.maps.DirectionsRenderer();

            this._directionsDisplay.setMap(Maps._mapInst);
        },

        /**
         * Hides all routes on the map
         */
        hideAll: function()
        {
            if (this._directionsDisplay instanceof google.maps.DirectionsRenderer) {
                this._directionsDisplay.setMap(null);
            }
        },

        /**
         * Gets route data by destination marker, then callback is running
         *
         * @param {google.maps.Marker} marker
         * @param {Function} successCb
         */
        getDataByDestinationMarker: function(marker, successCb) {

            var from = Maps._position,
                to = marker.position;


            // if user allowed to geolocalize
            if (from instanceof google.maps.LatLng) {
                AliorBase.callback(successCb, this, [marker.id, from, to]);

                // if user has not allowed to geolocalize, we need to ask him about
            } else {
               Maps.geolocalization.runProcess((function(positionInstance) {
                    AliorBase.callback(successCb, this, [marker.id, positionInstance, to]);
                }).bind(this));
            }
        },

        /**
         * Calculates route from to
         *
         * @param {google.maps.LatLng|String} from - current geolocalization
         * @param {google.maps.LatLng|String} to - destination
         * @param {String} routeId - route ID (relevant to marker ID)
         * @param {Function} successCb - success callback
         */
        calculate: function(from, to, routeId, successCb) {
            var self = this,
            request = {
                origin: from,
                destination: to,
                travelMode: google.maps.TravelMode[this.travelMode]
            };

            this._directionsService.route(request, (function(response, status) {
                if (status === google.maps.DirectionsStatus.OK) {
                    AliorBase.callback(successCb, this, [response]);
                }
            }).bind(this));
        }
    },

    /**
     * Geolocalization module
     */
    geolocalization: {

        /**
         * @property {Object} markerOptions - marker options
         */
        markerOptions: {
            icon: '.resources/templating-kit/themes/alior/img/localizator/userpointer.png',
            title: 'Twoja lokalizacja'
        },

        /**
         * @property {google.maps.Marker} currentMarker - current marker
         */
        currentMarker: null,

        /**
         * Sets marker on out current position
         *
         * @param {Function} successCb - callback after set the marker
         * @private
         */
        runProcess: function(successCb)
        {
            if (navigator.geolocation) {

                if (Maps._position instanceof google.maps.LatLng) {
                    AliorBase.callback(successCb, this, [Maps._position]);
                } else {
                    navigator.geolocation.getCurrentPosition((function(position) {
                        var positionInstance = new google.maps.LatLng(
                            position.coords.latitude,
                            position.coords.longitude
                        );

                        AliorBase.callback(successCb, this, [positionInstance]);
                    }).bind(this), function(err) {
                        // The Geolocation service failed
                        console.log('The Geolocation service failed');
                    });
                }
            } else {
                // Browser doesn't support Geolocation
                console.log('Browser doesn\'t support Geolocation');
            }
        },

        /**
         * Sets marker on the map
         *
         * @param {google.maps.LatLng} position - position, where we place the marker
         * @returns {google.maps.Marker}
         */
        setMarker: function(position)
        {
            var markerOptions = $.extend({
                position: position,
                map: Maps._mapInst
            }, this.markerOptions);

            var markerInstance = new google.maps.Marker(markerOptions);

            markerInstance.set('id', 'current_localization');

            this.hideCurrentMarker();

            this.currentMarker = markerInstance;

            return markerInstance;
        },

        /**
         * Removes the old marker if exists
         */
        hideCurrentMarker: function()
        {
            if (this.currentMarker instanceof google.maps.Marker) {
                this.currentMarker.setMap(null);
            }
        }
    }
};
